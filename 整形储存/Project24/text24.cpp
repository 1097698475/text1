#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>

//int main()
//{
//
//	//整形有三种表示方法 原码，反码，补码
//	//1.原码：直接将二进制按照正负数的形式翻译成二进制就可以
//	//2.反码：将原码的符号位不变，其他位依次按位取反就可以得到
//	//3.补码：反码+1就得到补码
//	//整形存到内存，存的是2进制数的补码再转化为16进制的数字
//
//
//	//整形有两种形式 有符号与无符号
//	//整形包括char int long short longlong，每一个又可分为有符号signed和无符号unsigned
//
//	//  1. 无符号的整形 三种码一模一样
//	//  2. 有符号的整形中正数，三种码也一模一样
//
//	//例：
//	int a = 20; //4个字节 32个比特位
//	//原码：00000000000000000000000000010100   有32位，其中第一位0是符号位：正为0，负为1
//	//反码：00000000000000000000000000010100
//	//补码：00000000000000000000000000010100
//	//放在内存中的为16进制：0x00000014    2进制的四个零为16进制的一个零（0x为16进制表示方法）
//
//	//  3. 有符号的整形的负数 三种码不一样
//
//	//例：
//	int b = -10;
//	//原码：10000000000000000000000000001010   有32位，其中第一位是符号位
//	//反码：11111111111111111111111111110101   符号位不变
//	//补码：1111 1111 1111 1111 1111 1111 1111 0110
//	//放在内存中的为16进制：0xFFFFFFF6     2进制每四个位对应16进制的一个位，如二进制的1111对应十六进制的15
//	return 0;
//}


//int main()
//{
//	//为什么要用补码？ 因为计算机的CPU只有加法运算
//	1 - 1;
//	//1+(-1)
//	//用原码：
//	//000000000000000000000001    1
//	//100000000000000000000001    -1
//	//100000000000000000000010    结果为-2，很明显错误
//
//	//用补码：
//	//000000000000000000000001    1   正数三个码都相同
//	//111111111111111111111111    -1
//	//000000000000000000000000    0   结果正确
//
//	return 0;
//}

//int main()
//{
//	int a = 20;
//	//00000000000000000000000000010100
//	//0x00 00 00 14     
//	//上面是补码的16进制，但储存的时候会储存成14 00 00 00
//	//大端（储存）模式：数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中
//	//小端（储存）模式：数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中
//	//14为数据的低位，&a为0x00B3FEC8 14 00 00 00    &a的下面是0x00B3FECC,可知14为低地址（00B3FEC8),下一个00（0x00B3FEC9)
//	//所以当前为小端储存模式
//	return 0;
//}

//其他见数据的储存备忘录
#include<windows.h>

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//会出现超大数的原因：-1的补码为32个1，打印的时候应该再变回原码，负数的
//		                  //原码本来要变，但是unsigned使得原码等于补码，变成了超大数
//		Sleep(100);
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));//答案是255，解答如下（按常规思路，1000个数里面没有\0，strlen终止不了，继续往后计数，结果为随机值
//	return 0;
//}

//注意到char，i从0到-128都是可以的，因为char......参考备忘录的环






//int main()
//{
//	 char i = 0;
//	int count = 0;
//	for (i = 0; i < 255; i++)
//	{
//		printf("hello world\n");
//		count++;
//	}
//	printf( "%d",count );
//	return 0;
//}

